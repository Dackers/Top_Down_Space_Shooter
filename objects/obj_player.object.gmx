<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_player_ship</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-1</depth>
  <persistent>0</persistent>
  <parentName>obj_TARGET_Parent</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Initialize Player

/*STATS */
//Name
name                = "USS Freedom"
//Engines
impulse_speed       = 1;
max_speed           = 5;
rotation_speed      = 2;
spin                = 0;
friction            = 0.06;
spin_friction       = friction/2;
flame_offsetX       = -30;
flame_offsetY       = 1;
//Weapons
// -Phasers
phaser_damage       = 2;
phaser_button       = gp_shoulderrb;
phaser_fire_rate    = room_speed/12.25;
can_shoot           = true;
num_phasers         = 2;
phaser_array[0,0]   = 6; //35; //x offset coordinate of first gun (obj_phaser.sprite_width/2 + 2 px)
phaser_array[0,1]   = -17; //y offset coordinate of first gun (4 px over)
phaser_array[1,0]   = 6; //35; //x offset coordinate of second gun (obj_phaser.sprite_width/2 + 2 px)
phaser_array[1,1]   = 17; //y offset coordinate of second gun (4 px over)
phaser_color        = 2;
phaser_knockback    = 5;
// -Torpedos
torpedo_button      = gp_shoulderr;
torpedo_fire_rate   = room_speed/1.5;
can_shoot_torpedo   = true;
num_torpedos        = 1;
torpedo_array[0,0]  = 30;
torpedo_array[0,1]  = 0;
torpedo_color       = make_colour_rgb(255, 0, 0)
//Targetting
t_first             = gp_padr;
t_last              = gp_padl;
t_next              = gp_padu;
t_previous          = gp_padd;
target              = noone;
range_circle        = true;
//Shields
instance_create(x,y,obj_shield);
max_shields         = 10;
shields             = max_shields;
regen_rate          = 1/room_speed; //(1 per second)
//Health
max_hp              = 60000;
hp                  = max_hp;
//Misc
sensor_radius       = 400;
image_index         = 0;
image_speed         = 0;
image_angle         = 0;
dir                 = 0;
image_xscale        = .25;
image_yscale        = image_xscale;
can_animate         = true;

/* CONTROLS */
//Keyboard
right_key           = vk_right;
left_key            = vk_left;
forward_key         = vk_up;
backward_key        = vk_down;
reticule            = instance_create(mouse_x, mouse_y, obj_reticule);
// Gamepad
pad_num             = 0;
h_move              = 0;
v_move              = 0;
h_point             = 0;
v_point             = 0;

//Manually set x/y because parralax starfield won't draw past -x or -y
x = 1000000;
y = 1000000;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Initialize targetting system

// This object is the BASE targetting object that you would use for your player 
// or whatever object requires the targetting. It can be incorporated into AI
// objects easily, since the only thing that you need to set is the PARENT object
// that is to be targeted. This object ONLY contains the targeting scripts.
// To see an example object that uses the targeting scripts, please look at 
// the "obj_TARGET_Player" in the "DEMO ONLY" folder.

///////////////////////////////////////////////////////////////////////////////////////

// We need to initialise the targeting codes in the PLAYER object
// (or in the object that requires a targetting list). This script 
// will initialise certain internal variables that are required 
// for all further targetting scripts to work. The variables create are:
/*

e_pos - The position in the target list of the current target
e_num - The maximum targets that the list should contain
e_cur - The ID of the current target or 0 if there is none
e_rng - The range that the player (or whatever) is "looking" for targets as a rdius
target_list - A DS list containing the target information

*/

// These variables can be accessed at any time from within any further events
// within this object for drawing or parsing. Note that you should set a value 
// for SIZE and RANGE, as these variables do not exist and are simply there to 
// mark what you need to input.

scr_TARGET_Init(global.list_size, global.range, obj_TARGET_Parent, room_speed / 5);

// This alarm calls the list code for the HUD and targeting to be updated.
// The alarm calls the "scr_TARGET_Update" script which has a couple of 
// loops and is therefore not optimal for a step event call, although it can be
// placed there for faster updating, as long as it is called BEFORE the 
// "scr_TARGET_Step()" script. If you want it to update slower or faster
// then raise the alarm amount. Currently it runs every 6 steps...

alarm[2] = update_speed; // For target update
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Cleanup

// Free any resources used by the trageting scripts
scr_TARGET_Cleanup();

game_restart();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>can_animate = true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Update target list
// Update the target list, giving it the PARENT object to use for targetting

scr_TARGET_Update(obj_TARGET_Parent, false);

//Set the alarm to run the code again. this can be changed to whatever you want.
//This whole code can actually go in the step or begin_step events, but I used an
//alarm as it saves cpu cycles...

alarm[2] = update_speed;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Torpedos
can_shoot_torpedo = true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Phasers
can_shoot = true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Limit speed

speed = min(speed, max_speed);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Create Thrust Flame

if (v_move &lt; 0) and !instance_exists(obj_thrustflame)
{
    var flame_id;
    flame_id = instance_create(x+lengthdir_x(flame_offsetX, image_angle), y+lengthdir_y(flame_offsetX, image_angle), obj_thrustflame);
    flame_id.attached = id;
    flame_id.image_xscale = -v_move;
    flame_id.image_yscale = -v_move;
    flame_id.image_index = 0;
    flame_id.image_angle = image_angle;
}
if instance_exists(obj_thrustflame) and v_move &gt;= 0
{
    with obj_thrustflame instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Move and Shoot

/* Gamepad inputs */
h_move  = gamepad_axis_value(pad_num, gp_axislh);
//h_move  = gamepad_axis_value(pad_num, gp_axisrh);
v_move  = gamepad_axis_value(pad_num, gp_axislv);
h_point = gamepad_axis_value(pad_num, gp_axisrh);
v_point = gamepad_axis_value(pad_num, gp_axisrv);

/* Keyboard Input */
if (mouse_check_button(mb_right)) {
    image_angle = point_direction(x, y, mouse_x, mouse_y);
}

/* Banking motion */
// ISSUES:
//      (1) ship jitters when gp_axislh is anywhere other than -1, 0 or 1
//      (2) ship snaps full left and right if gp_axislh is moved rapidly from 1 to -1 and vice versa
var magnitude = h_move;
clamp(magnitude, -1, 1);

if can_animate
{
    can_animate = false;
    alarm[3] = room_speed/15;
   
    if (abs(magnitude) &gt; 0) and (image_index &lt; (abs(magnitude) * image_number-1))
    {
        image_index += 1;
    }
    else if image_index != 0
    {
        image_index -= 1;
    }
    
    if (magnitude &gt; 0)
        { image_yscale = -.5; }
    else if (magnitude &lt; 0)
        { image_yscale = .5; }
        
    if (magnitude == 0) { image_index -= 1; }
    if (image_index &lt; 0){ image_index = 0; }
}

/* Vert and Horiz Movement */
motion_add(image_angle, impulse_speed * -v_move);
motion_add(image_angle + 90, impulse_speed * -h_move);

/* Rotation Movement */
if (abs(h_point))
{
    spin = -h_point * rotation_speed;
}
if (spin &gt; 0)
{
    spin -= spin_friction;
    image_angle +=  spin;
}
if (spin &lt; 0)
{
    spin += spin_friction;
    image_angle +=  spin;
}
if(abs(spin) &lt;= spin_friction){ spin = 0; }

/* Targetting */
if gamepad_button_check_pressed(pad_num, t_first) { scr_TARGET_First(true); }
if gamepad_button_check_pressed(pad_num, t_last) { scr_TARGET_First(false); }
if gamepad_button_check_pressed(pad_num, t_next) { scr_TARGET_Change(false); }
if gamepad_button_check_pressed(pad_num, t_previous) { scr_TARGET_Change(true); }

/* Phaser Fire */
if gamepad_button_check(pad_num, phaser_button) and can_shoot
{
    can_shoot = false;
    alarm[0] = phaser_fire_rate;
    scr_fire_phasers(phaser_array, phaser_color)
}

/* Torpedo Fire */
if gamepad_button_check_pressed(pad_num, torpedo_button) and can_shoot_torpedo
{
    can_shoot_torpedo = false;
    alarm[1] = torpedo_fire_rate;
    scr_fire_torpedos(torpedo_array, torpedo_color)
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Targetting

// This script maintains the currently targeted enemy position
// within the target list so that it doesn't "jump" as enemies 
// come and go. It makes the HUD a nicer experience for the 
// users and keeps the targetting obvious and easy.

scr_TARGET_Step();

range_circle ^= gamepad_button_check_pressed(pad_num, gp_face2);
with (obj_reticule) {
    x = mouse_x;
    y = mouse_y;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Phaser Bank Location

switch (image_index)
{
    case 0:
        phaser_array[0,1] = -17;
        phaser_array[1,1] = 17;
        break;
    case 1:
        phaser_array[0,1] = -16;
        phaser_array[1,1] = 16;
        break;
    case 2:
        phaser_array[0,1] = -15;
        phaser_array[1,1] = 15;
        break;
    case 3:
        phaser_array[0,1] = -14;
        phaser_array[1,1] = 14;
        break;
    case 4:
        phaser_array[0,1] = -13;
        phaser_array[1,1] = 13;
        break;
    case 5:
        phaser_array[0,1] = -12;
        phaser_array[1,1] = 12;
        break;
    case 6:
        phaser_array[0,1] = -11;
        phaser_array[1,1] = 11;
        break;
    case 7:
        phaser_array[0,1] = -10;
        phaser_array[1,1] = 10;
        break;
    case 8:
        phaser_array[0,1] = -7;
        phaser_array[1,1] = 7;
        break;
    case 9:
        phaser_array[0,1] = -6;
        phaser_array[1,1] = 6;
        break;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Cleanup
scr_TARGET_Cleanup();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_set_colour(c_white);
draw_text(200, 200, "Player Image Index: " + string(obj_player.image_index)+
                    "#v_move: " + string(v_move));
if instance_exists(obj_thrustflame)
{
    draw_text(200, 300, "Thrust Flame Image Index: " + string(obj_thrustflame.image_index));
}

/*draw_text(200, 200, "image_angle: " + string(obj_player.image_angle) +
                    "#view_wview[0]: " + string(view_wview[0]) +
                    "#view_hview[0]: " + string(view_hview[0]) +
                    "#x: " + string(obj_player.x) +
                    "#y: " + string(obj_player.y) +
                    "#obj_phaser: " + string(instance_number(obj_phaser)));
*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw Targeting Circle
draw_self();
scr_TARGET_Draw(id, c_red, 32, 32);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
